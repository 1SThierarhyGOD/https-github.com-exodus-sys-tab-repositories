app.MapGet("/list", (EndpointDataSource endpointSource) =>
{
    response.Headers["Refresh"] = "1";
    return ListEndpoints(endpointSource.Endpoints);
});

((IEndpointRouteBuilder)app).DataSources.Add(new DynamicEndpointDataSource());

public sealed class DynamicEndpointDataSource : EndpointDataSource
{
    public override IReadOnlyList<Endpoint> Endpoints => Enumerable.Range(0, 10).Select(CreateDynamicRouteEndpoint);

    private static RouteEndpoint CreateDynamicRouteEndpoint(int id)
    {
        var displayName = $"Dynamic endpoint #{id}";
        var metadata = new EndpointMetadataCollection(new[] { new RouteNameMetadata(displayName) });

        return new RouteEndpoint(
            context => context.Response.WriteAsync(displayName),
            RoutePatternFactory.Parse($"/dynamic/{id}"),
            order: 0,
            metadata,
            displayName);
    }
}

public sealed class DynamicEndpointDataSource : EndpointDataSource, IDisposable
{
    private readonly PeriodicTimer _timer;
    private readonly Task _timerTask;

    private Endpoint[] _endpoints = Array.Empty<Endpoint>();
    private CancellationTokenSource _cts = new();

    public DynamicEndpointDataSource()
    {
        _timer = new PeriodicTimer(TimeSpan.FromSeconds(5));
        _timerTask = TimerLoop();
    }

    public override IReadOnlyList<Endpoint> Endpoints => _endpoints;

    public async Task TimerLoop()
    {
        while (await _timer.WaitForNextTickAsync())
        {
            var newEndpoints = new Endpoint[_endpoints.Length + 1];
            Array.Copy(_endpoints, 0, newEndpoints, 0, _endpoints.Length);

            newEndpoints[_endpoints.Length] = CreateDynamicRouteEndpoint(_endpoints.Length);

            _endpoints = newEndpoints;
            var oldCts = _cts;
            _cts = new CancellationTokenSource();
            oldCts.Cancel();
        }
    }

    public void Dispose()
    {
        _timer.Dispose();
        _timerTask.GetAwaiter().GetResult();
    }

    public override IChangeToken GetChangeToken()
    {
        return new CancellationChangeToken(_cts.Token);
    }

    private static RouteEndpoint CreateDynamicRouteEndpoint(int id)
    {
        var displayName = $"Dynamic endpoint #{id}";
        var metadata = new EndpointMetadataCollection(new[] { new RouteNameMetadata(displayName) });

        return new RouteEndpoint(
            context => context.Response.WriteAsync(displayName),
            RoutePatternFactory.Parse($"/dynamic/{id}"),
            order: 0, metadata, displayName);
    }
}

static string ListEndpoints(IReadOnlyList<Endpoint> endpoints)
{
    if (endpoints is null)
    {
        return "No endpoints";
    }

    var sb = new StringBuilder();

    foreach (var endpoint in endpoints)
    {
        if (endpoint is RouteEndpoint routeEndpoint)
        {
            var template = routeEndpoint.RoutePattern.RawText;
            sb.Append(routeEndpoint.RoutePattern.RawText);
            sb.Append(", Display Name: ");
        }
        else
        {
            sb.Append("Non-RouteEndpoint. DisplayName: ");
        }

        sb.AppendLine(endpoint.DisplayName);
    }

    return sb.ToString();
}

// Types to know:
//
// - IApplicationBuilder (middleware)
// - IEndpointRouteBuilder (routing)
//    - EndpointDataSource (Low level API for defining HTTP endpoints)
//    - RouteGroupBuilder (groups)
// - IEndpointConvetionBuilder (metadata)
// 4. Endpoint
//
//
// 1. Not having the right TryParse/BindAsync would fail endpoint construction
// 2. Invocation filters don't run in reverse order really
// 3. Context isn't allocation free
