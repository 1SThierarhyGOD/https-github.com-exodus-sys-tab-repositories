// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Text;

namespace Microsoft.Extensions.Caching.Hybrid.Internal;

// logic related to the payload that we send to IDistributedCache
internal sealed partial class DefaultHybridCache
{
    // layout:
    // 2 bytes: [Sentinel/Version]
    // 2 bytes: [Flags]
    // 8 bytes: [Entropy][CreationTime]
    // 4 bytes: [PayloadSize]
    // 5 bytes: [TTL]
    // 1 byte: [TagCount]
    // (String): Key
    // TagCount * (String): tags
    // remaining bytes: payload (compressed if flag set)
    //
    // Sentinel/Version: fixed prefix value of 0x0301 - 01 is version; 03 prefix avoids
    // confusion with common serializers - invalid in xml, json, protobuf, etc
    //
    // (String) consists of 1-or-two bytes of length as a prefix; if the LSB of the
    // first byte is 0, it is a 1-byte prefix corresponding to up to 127 bytes of
    // content; if the LSB of the first byte is 1, it is combined with the next
    // byte (LE) to give up to 32767 bytes of content; keys and strings above this size are
    // not supported. The prefix is followed by the specified number of bytes which should
    // be interpreted as UTF8.
    //
    // Entropy and CreationTime are packed as a single little-endian U64, with Entropy in
    // the high 19 bits and CreationTime in the low 45 bits.
    // Entropy is 19 bits of random noise generated by the sending node; this noise
    // is used to avoid self-invalidation, i.e. if the entropy and creation time
    // of a received invalidation message BOTH match against the local L1 value,
    // it is presumed to be our own data, and the invalidation is ignored; this
    // gives a *same millisecond* collision a 1-in-524288 chance of incorrectly
    // retaining data, which is acceptable. We could also choose to include the
    // PayloadSize in this calculation, which would further reduce this (a match
    // here also suggests - inconclusively - that the colliding data is identical);
    // for that reason, Entropy, CreationTime and PayloadSize are early bytes

    // CreationTime is 45 bits as milliseconds into UTC unix epoch as UTC,
    // this is 5 bytes and 5 bits; this uses little-endian integer encoding
    //
    // TTL is 5 bytes as milliseconds, little-endian
    //
    // TagCount is the number of tags; a maximum of 255 tags per entry is supported
    //
    // PayloadSize is the size of the body payload in bytes, AFTER EXPANSION if compressed,
    // as a 32-bit little-endian integer; maximum supported payload size is ~4GiB; a future
    // Flags entry may allow for larger PayloadSize chunks
    //
    // Note on time: 45 bits (CreationTime) gives us 35184372088831ms
    // 35184372088831ms is 35184372088s, 586406201 minutes, 9773436 hours, 407226 days,
    // which is 1143 years
    //
    // 40 bits (TTL) gives us 1099511627775ms, which is nearly 35 yeas; plenty for a cache
    // system (24 bits only gives us 24 days, which is a little on the tight side)
    internal readonly struct PayloadHeader(ushort flags, ulong entropyAndCreationTime, uint payloadSize, ulong ttl, string key, string[] tags)
    {
        public override string ToString() => $"{Key} ({PayloadSize} bytes)";

        public ushort Flags { get; } = flags;
        public string Key { get; } = key;

        public ulong EntropyAndCreationTime { get; } = entropyAndCreationTime;
        public ulong CreationTime => EntropyAndCreationTime & 0x00001FFFFFFFFFFF; // low 45 bits

        public uint PayloadSize { get; } = payloadSize;
        public ulong TTL { get; } = ttl;

        public string[] Tags { get; } = tags;

        private static readonly UTF8Encoding UTF8 = new(false);

        public void Write(IBufferWriter<byte> destination)
        {
            if (Tags.Length > 255)
            {
                throw new InvalidOperationException($"Maximum tag count (255) exceeded");
            }
            var buffer = destination.GetSpan(22);
            buffer[0] = 0x03; // sentinel
            buffer[1] = 0x01; // version
            BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(2), Flags);
            BinaryPrimitives.WriteUInt64LittleEndian(buffer.Slice(4), EntropyAndCreationTime);
            BinaryPrimitives.WriteUInt32LittleEndian(buffer.Slice(12), PayloadSize);
            BinaryPrimitives.WriteUInt32LittleEndian(buffer.Slice(16), (uint)TTL); // low 32
            buffer[20] = (byte)(TTL >> 32); // final TTL octet
            buffer[21] = (byte)Tags.Length;

            destination.Advance(22);
            WriteString(destination, Key, nameof(Key));
            foreach (var tag in Tags)
            {
                WriteString(destination, tag, nameof(Tags));
            }

            static void WriteString(IBufferWriter<byte> destination, string value, string kind)
            {
                if (value.Length == 0)
                {
                    destination.GetSpan(1)[0] = 0;
                    destination.Advance(1);
                    return;
                }

                var len = UTF8.GetByteCount(value);
                if (len <= 127)
                {
                    var buffer = destination.GetSpan(len);
                    buffer[0] = (byte)(len << 1);
                    if (buffer.Length > len)
                    {
                        // write in the existing buffer
#if NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                        var actual = UTF8.GetBytes(value, buffer.Slice(1));
                        Debug.Assert(actual == len);
#else

                        unsafe
                        {
                            fixed (char* cPtr = value)
                            fixed (byte* bPtr = buffer)
                            {
                                var actual = UTF8.GetBytes(cPtr, value.Length, bPtr + 1, len);
                                Debug.Assert(actual == len);
                            }
                        }
#endif
                        destination.Advance(len + 1);
                    }
                    else
                    {
                        // just write the header, and use shared helper for the value
                        destination.Advance(1);
                        WriteRawSlow(destination, value, len);
                    }
                }
                else if (len <= 32767)
                {
                    var buffer = destination.GetSpan(2);
                    buffer[0] = (byte)((len << 1) | 0x01); // 7 low bits and the MSB marker
                    buffer[1] = (byte)(len >> 7); // next 8 bits
                    destination.Advance(2);
                    WriteRawSlow(destination, value, len);
                }
                else
                {
                    throw new InvalidOperationException($"Maximum {kind} length (32767 bytes) exceeded");
                }
            }

            static void WriteRawSlow(IBufferWriter<byte> destination, string value, int bytes)
            {
#if NET5_0_OR_GREATER
                var actual = UTF8.GetBytes(value, destination);
                Debug.Assert(actual == bytes);
#else
                var lease = ArrayPool<byte>.Shared.Rent(bytes);
                var actual = UTF8.GetBytes(value, 0, value.Length, lease, 0);
                Debug.Assert(actual == bytes);
                destination.Write(new(lease, 0, bytes));
                ArrayPool<byte>.Shared.Return(lease);
#endif
            }
        }

        public static bool TryParse(ref ReadOnlySpan<byte> bytes, out PayloadHeader header)
        {
            if (bytes.Length >= 22)
            {
                // read the prefix
                switch (BinaryPrimitives.ReadUInt16LittleEndian(bytes)) // [0,1]
                {
                    case 0x0103: // note order reversed; optimizing for little-endian CPU
                        var flags = BinaryPrimitives.ReadUInt16LittleEndian(bytes.Slice(2)); // [2,3]
                        var entropyAndCreationTime = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(4)); // [4,11]
                        var payloadSize = BinaryPrimitives.ReadUInt32LittleEndian(bytes.Slice(12)); // [12,15]
                        var ttl = BinaryPrimitives.ReadUInt32LittleEndian(bytes.Slice(16)) | (((ulong)bytes[20]) << 32); // [16-20], with the final byte as the highest
                        var tagCount = bytes[21]; // [21]

                        bytes = bytes.Slice(22);
                        if (!TryReadString(ref bytes, out var key))
                        {
                            break;
                        }

                        if (bytes.Length < tagCount) // we'll need *at least* one byte per tag
                        {
                            break;
                        }
                        string[] tags = tagCount == 0 ? [] : new string[tagCount];
                        bool tagFail = false;
                        for (int i = 0; i < tags.Length; i++)
                        {
                            if (!TryReadString(ref bytes, out tags[i]))
                            {
                                tagFail = true;
                                break;
                            }
                        }
                        if (tagFail)
                        {
                            break;
                        }

                        header = new(flags, entropyAndCreationTime, payloadSize, ttl, key, tags);
                        return true;
                }
            }
            // unknown data
            header = default;
            return false;

            static bool TryReadString(ref ReadOnlySpan<byte> bytes, out string value)
            {
                value = "";
                if (bytes.IsEmpty)
                {
                    return false;
                }

                int payloadBytes = bytes[0];
                int headerBytes;
                if ((payloadBytes & 0x01) == 0) // LSB clear? single-byte
                {
                    headerBytes = 1;
                }
                else
                {
                    // combine LE with next byte
                    if (bytes.Length < 2)
                    {
                        return false;
                    }
                    payloadBytes |= bytes[1] << 8;
                    headerBytes = 2;
                }
                payloadBytes >>= 1; // remove the marker bit
                if (payloadBytes == 0)
                {
                    bytes = bytes.Slice(headerBytes);
                    return true;
                }
                if (bytes.Length >= headerBytes + payloadBytes)
                {
                    var payload = bytes.Slice(headerBytes, payloadBytes);
#if NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                    value = UTF8.GetString(payload);
#else
                    unsafe // shim
                    {
                        fixed (byte* ptr = payload)
                        {
                            value = UTF8.GetString(ptr, payloadBytes);
                        }
                    }
#endif
                    bytes = bytes.Slice(headerBytes + payloadBytes);
                    return true;
                }

                // not enough data
                return false;

            }
        }
    }
}
